# 模糊测试

## 一. 前言

**模糊测试用例**表所含列如下：

1. 名称（name）：测试用例的名称。
2. 测试用例 id（test_case_id）：测试用例的唯一标识符。
3. 描述（desc）：对测试用例的描述。
4. 属性：暂时还没想好
5. 请求对象：对应 boofuzz.Request

注意：一个模糊测试用例仅含有一个请求对象，二者之间是一对一的关系！

一个请求对象通常又包含多个字段，而一个字段通常包括：

1. 长度（size）：指示测试用例占据的比特/字节数。
2. 单位（unit）：比特或字节
3. 默认值（default_value）：测试用例的默认值。
4. 字节顺序（endian）：测试用例的字节顺序，大端用 `>` 表示，小端用 `<` 表示。
5. 变异规则（fuzzable）：表示是否要对用例进行模糊测试，用 `True` 或 `False` 表示。

## 二. 自定义测试用例

### 2.1 创建模糊测试用例组

传入名称和描述（可选）创建一个模糊测试用例组。

目前设想的请求格式如下：

```json
xxxxx/?groupname=test // 请求创建一个名为 test 的模糊测试用例组

```

后端逻辑：

根据名称及描述再结合用户的 id 向模糊测试用例组**表**插入一行。

- 在创建完用例组后，用户就可以选择向该组插入测试用例了。

### 2.2 创建模糊测试用例

当用户选中某个模糊测试用例组后，可以传入以下的信息向组中添加一个模糊测试用例：

1. 用例组名称
2. 用例名称
3. 用例属性（可选，暂时还没想好）

目前设想的请求格式如下：

```json
xxxxx/?groupname=test&name=test // 在 test 用例组中创建一个名为 test 的用例。
```

目前设想的后端逻辑如下：

1. 根据测试用例组名称再结合用户 的 id 查询用例组表获取特定用例组的 id。
2. 然后再根据用例的名称结合查询出的用例组 id 向测试用例表插入一行。
3. 为该测试用例唯一对应的 request 随机赋值一个 id 和 name
4. 响应自定义测试用例成功。

### 2.3 设置模糊测试用例字段

场景描述：当用户选中某用例组下的某用例，此时可向该用例增添字段，在前端要以树形的结构显示该用例的字段结构。

向模糊测试用例添加字段要传入的信息如下：

1. fuzzing_case_group_name 和 fuzzing_case_name，
2. 可选的 block_name
3. 依据字段的类型在前端显示对应的字段信息，并让用户自行填写并传入后端。

一个 byte 类型的字段含有的字段信息如下：

1. name
2. default_value
3. max_num
4. endian
5. output_format
6. signed
7. full_range
8. fuzz_values
9. fuzzable

目前设想的后端逻辑如下：

1. 首先寻找具有指定用户 id 和名称的测试用例组，并获取其组id，
2. 然后根据组 id 和测试用例名称寻找对应的测试用例，并获取其用例 id，
3. 根据模糊测试用例 id 寻找对应的 request id。
4. 接着根据字段类型和字段信息再结合 request id 向对应的字段表插入一行记录

注意：如果用户选择在 Block 类型字段下新增一个子字段，后端如何处理？

首先传入的信息除了之前的之外，还要额外传入一个 block_name。根据 block_name 做如下几件事情：

1. 寻找具有指定 block name 和 request id 的 block id，
2. 然后根据传入的信息结合 block id 向对应类型的字段表插入一行记录。

> 关于自引用可参看[此处](https://www.cnblogs.com/huchong/p/8298603.html)

## 三. 测试设置

### 系统用例库定义

以 JSON 的格式返回系统默认的测试用例库，大概是如下的样子：

```json
    "default_group": {
        
        "UMAS": {
            "Read ID": "读取 ID",
            
        },
        
        "ENIP": {
            "Register Session": "注册会话",
            "Diagnostic Status": "诊断状态",
            "Forward Open": "转发打开",
            "Logical Read": "逻辑读取",
            
        },
        
        "S7C": {
            "Setup Communication": "建立连接",
            "Read SZL": "读取系统状态列表"
            
        }
    }

```

具体的实现可以考虑在 python 中创建一个类似的字典。

### 测试用例库读取

- 读取测试用例库 = 读取用户的全部测试用例组

算法：

1. 利用 `JWT` 判断用户是否登录。如果用户未登录或者登录 token 已过期，那么响应未登录并跳转登录页面。
2. 否则从 `JWT` 中提取用户 id，以此为条件从 TestCaseGroup 表查询该用户拥有的所有测试用例组，并获取这些用例组的 id。
3. 然后再根据这些用例组的 id 为条件查询 FuzzyTestCase 表获取测试用例名称和描述。
4. 将上述信息和系统默认用例组返回。

### 测试套件设置

场景描述：用户从测试用例库中任选多个测试用例，然后将这些用例加入到测试套件并放入套件库中。（套件库也称为测试套件模板库）

设置测试套件需要的信息分别是：

1. 模糊测试用例组名称
2. 模糊测试用例
3. 套件名称
4. 套件描述

**注意：仅当用户在测试套件页面点击了保存套件按钮时，才触发此路由。**

算法：

1. JWT 鉴权。
2. 根据套件名称和套件描述向 TestSuites 表插入一行。（id 自增且初始值为零，user_id 则是当前用户的）
3. 根据测试用例**组**的名称查询 TestCaseGroups 表获取指定测试用例组的 id。
4. 再根据获取到的**组 id** 查询 FuzzyTestCase 表获取特定的测试用例。
5. 查询刚向 TestSuites 表中插入的行记录的 id
6. 将得到的测试用例的 test_suite_id 修改为刚得到的 id。

### 测试套件库读取

- 传入测试套件的名称，获取该套件下的所有测试用例。

操作：

1. JWT 鉴权。
2. 根据套件名查询 TestSuites 表获取套件 id。
3. 根据套件 id 查询 FuzzyTestCase 表获取多行测试用例的名称
4. 将这些名称打包成 JSON 格式返回

### 连接测试用例并执行

- 用户选中模板库下的某个测试套件，然后设置该套件下各个测试用例间的连接关系。
参数：测试套件名称和连接关系逻辑（JSON格式）

> 这里先不考虑回调监视器

```json
{
    "测试套件名":
    {
        "测试用例一（名称）": "测试用例二（名称）",
        "测试用例二（名称）": "测试用例三（名称）"
    }
}

```

操作：

1. JWT 鉴权。
2. 根据测试套件名称查询 TestSuites 表获取套件 id。
3. 根据套件 id 查询 FuzzTestCase 表获取属于该套件的所有测试用例。
4. 对每个测试用例，依据其各项属性，定义 Boofuzz 原语，并构造 Request 对象（Request 对象的名称就是测试用例的名称）。
5. 依次提取出连接关系逻辑中的每对测试用例，将名称对应的 Request 对象连接起来。
6. 进行模糊测试。
7. 返回模糊测试过程中的数据（顺便可以返回连接图）。